"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[916],{3023(e,n,r){r.d(n,{R:()=>o,x:()=>d});var s=r(3696);const a={},t=s.createContext(a);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(t.Provider,{value:n},e.children)}},9804(e,n,r){r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"going-deeper/middlewares","title":"Middleware","description":"Just like any other web frameworks, Pashmak supports middlewares. Middlewares are pieces of code that wrap execution of controller methods. They can be used for various purposes such as authentication, logging, request modification, response modification, etc. Middlewares are functions, objects, or classes that can execute with direct access to the request and response objects. The main distinction between middlewares in Pashmak vs nestjs or express is that middlewares can execute code before AND after the controller method.","source":"@site/docs/going-deeper/middlewares.md","sourceDirName":"going-deeper","slug":"/going-deeper/middlewares","permalink":"/pashmak/docs/going-deeper/middlewares","draft":false,"unlisted":false,"editUrl":"https://github.com/devbro1/pashmak/blob/master/docs/docs/going-deeper/middlewares.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Logger","permalink":"/pashmak/docs/going-deeper/logger"},"next":{"title":"Queue and Messaging","permalink":"/pashmak/docs/going-deeper/queue"}}');var a=r(2540),t=r(3023);const o={sidebar_position:7},d="Middleware",i={},l=[{value:"types of middleware",id:"types-of-middleware",level:2},{value:"functional middlewares",id:"functional-middlewares",level:3},{value:"Example",id:"example",level:4},{value:"Middleware Class",id:"middleware-class",level:3},{value:"Example",id:"example-1",level:4},{value:"Middleware Object",id:"middleware-object",level:3},{value:"Example of Singleton Middleware Class",id:"example-of-singleton-middleware-class",level:4},{value:"Example of Middleware Object",id:"example-of-middleware-object",level:4},{value:"order of middleware execution",id:"order-of-middleware-execution",level:2},{value:"Use Cases for Middlewares",id:"use-cases-for-middlewares",level:2},{value:"read response body after controller execution",id:"read-response-body-after-controller-execution",level:4}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"middleware",children:"Middleware"})}),"\n",(0,a.jsx)(n.p,{children:"Just like any other web frameworks, Pashmak supports middlewares. Middlewares are pieces of code that wrap execution of controller methods. They can be used for various purposes such as authentication, logging, request modification, response modification, etc. Middlewares are functions, objects, or classes that can execute with direct access to the request and response objects. The main distinction between middlewares in Pashmak vs nestjs or express is that middlewares can execute code before AND after the controller method."}),"\n",(0,a.jsx)(n.h2,{id:"types-of-middleware",children:"types of middleware"}),"\n",(0,a.jsx)(n.p,{children:"There are 3 types of middlewares you can create:"}),"\n",(0,a.jsx)(n.h3,{id:"functional-middlewares",children:"functional middlewares"}),"\n",(0,a.jsx)(n.p,{children:"similar to expressjs middlewares they are just functions that are executed at each request."}),"\n",(0,a.jsxs)(n.admonition,{type:"danger",children:[(0,a.jsxs)(n.p,{children:["the major point is you need to call ",(0,a.jsx)(n.code,{children:"await next()"})," instead of ",(0,a.jsx)(n.code,{children:"next()"}),", otherwise you can break the promise chain and cause unpredictable behaviors."]}),(0,a.jsx)(n.p,{children:"These unpredictable behaviors may include a code that is running even after response is sent to client, errors that are not captured by http error handler, error that response is already sent to client, etc."})]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Request, Response } from "@devbro/pashmak/router";\n\nexport async function requirePermissionsMiddleware(\n  required_permissions: Permission | Permission[],\n) {\n  return async function (\n    req: Request,\n    res: Response,\n    next: () => Promise<void>,\n  ): Promise<void> {\n    let auth_user = ctx.get("getAuthenticatedUser");\n\n    canUserOrFail(auth_user, required_permissions);\n\n    try {\n      // if you do not want to handle errors here, you can remove try catch block entirely\n      await next();\n      // post controller code\n    } catch (error) {\n      // error handling code if controller or any other middleware throws an error\n      throw error;\n    }\n  };\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"middleware-class",children:"Middleware Class"}),"\n",(0,a.jsx)(n.p,{children:"It is a class definition that extends Middleware class. Everytime a request is processed, a new instance of this class is created before executing the middleware part.\nThis is ideal for when you need to run a middleware where it needs to track some data from before and acter controller execution per each request."}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Middleware, Request, Response } from "@devbro/pashmak/router";\n\nexport class ResponseLoggerMiddleware extends Middleware {\n  static getInstance(params: any): Middleware {\n    return new ResponseLoggerMiddleware(params);\n  }\n  async call(\n    req: Request,\n    res: Response,\n    next: () => Promise<void>,\n  ): Promise<void> {\n    await next();\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"middleware-object",children:"Middleware Object"}),"\n",(0,a.jsx)(n.p,{children:"There may exists situations where you want to improve performance and not instantiate on every request.\nor you want to be able to track data between requests. there are two approaches to do this. First use a singleton pattern within Middleware Class.\nsecond use a Middleware Object."}),"\n",(0,a.jsx)(n.h4,{id:"example-of-singleton-middleware-class",children:"Example of Singleton Middleware Class"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Middleware, Request, Response } from "@devbro/pashmak/router";\n\nexport class RequestCounterMiddleware extends Middleware {\n  static instance: RequestCounterMiddleware | undefined = undefined;\n  counter: number = 0;\n\n  static getInstance(params: any): Middleware {\n    if (!this.instance) {\n      this.instance = new RequestCounterMiddleware(params);\n    }\n    return this.instance;\n  }\n\n  async call(\n    req: Request,\n    res: Response,\n    next: () => Promise<void>,\n  ): Promise<void> {\n    this.counter++;\n    await next();\n  }\n}\n\n// Using Middlewares\nrouter().addRoute(["GET"], "/api/v1/some-endpoint", someControllerMethod, {\n  middlewares: [RequestCounterMiddleware],\n});\n'})}),"\n",(0,a.jsx)(n.h4,{id:"example-of-middleware-object",children:"Example of Middleware Object"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Middleware, Request, Response } from "@devbro/pashmak/router";\n\nexport class RequestCounterMiddleware extends Middleware {\n  counter: number = 0;\n\n  constructor() {\n    super();\n  }\n\n  async call(\n    req: Request,\n    res: Response,\n    next: () => Promise<void>,\n  ): Promise<void> {\n    this.counter++;\n    await next();\n  }\n}\n\n// Using Middlewares\nrouter().addRoute(["GET"], "/api/v1/some-endpoint", someControllerMethod, {\n  middlewares: [new RequestCounterMiddleware()],\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"The caveat of this approach is that this object is not shared with other routes. If you add a middleware object as global middleware to router, then it is shared with all routes within that router."}),"\n",(0,a.jsx)(n.h2,{id:"order-of-middleware-execution",children:"order of middleware execution"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"from global router"}),"\n",(0,a.jsx)(n.li,{children:"from child router (if any)"}),"\n",(0,a.jsx)(n.li,{children:"from class middlewares"}),"\n",(0,a.jsx)(n.li,{children:"from request method of controller class or functional controller"}),"\n"]}),"\n",(0,a.jsx)(n.mermaid,{value:'graph LR\n  http_req_res --\x3e|1| middleware1\n  middleware1 --\x3e|2| middleware2\n  middleware2 --\x3e|3| middleware3\n  middleware3 --\x3e|4| Controller\n  Controller --\x3e|5| middleware3\n  middleware3 --\x3e|6| middleware2\n  middleware2 --\x3e|7| middleware1\n  middleware1 --\x3e|8| http_req_res\n\n  http_req_res@{ label: "HTTP Connection" }\n  middleware1@{ label: "Global middleware" }\n  middleware2@{ label: "Controller class middleware" }\n  middleware3@{ label: "Controller method middleware" }'}),"\n",(0,a.jsx)(n.p,{children:"numbers indicate the order of execution."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { router } from "@devbro/pashmak/facades";\n\n// 1. Global middleware (runs first)\nrouter().addGlobalMiddleware(authMiddleware);\n\n// 2. Controller-level middleware (runs second)\n@Controller("/api/v1/users", {\n  middlewares: [checkPermissions],\n})\nexport class UserController extends BaseController {\n  // 3. Method-level middleware (runs last)\n  @Get({ middlewares: [logRequest] })\n  async list() {\n    return [];\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"use-cases-for-middlewares",children:"Use Cases for Middlewares"}),"\n",(0,a.jsx)(n.h4,{id:"read-response-body-after-controller-execution",children:"read response body after controller execution"}),"\n",(0,a.jsxs)(n.p,{children:["Response object is actually node native ",(0,a.jsx)(n.code,{children:"ServerResponse"})," response object. Within http and router modules, the response body is written by calling ",(0,a.jsx)(n.code,{children:"res.write()"})," or ",(0,a.jsx)(n.code,{children:"res.end()"})," method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { Request, Response } from "@devbro/pashmak/router";\n\nreturn async function logResponse(\n  req: Request,\n  res: Response,\n  next: () => Promise<void>,\n): Promise<void> {\n  const old_end = res.write;\n  let buff_data = "";\n  res.write = function (data: any, ...args: any[]) {\n    let buffered_data = "";\n    if (data) {\n      buffered_data = data.toString();\n      buff_data += buffered_data;\n    }\n    old_end.apply(res, [buffered_data, ...args]);\n  };\n\n  await next();\n\n  // now buff_data contains the full response body\n  logger.info("Response Body:", { response_body: buff_data });\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This solution should work in most cases. Keep in mind another way to write response body is using ",(0,a.jsx)(n.code,{children:"res.write()"})," method. This method is used to write buffer and streams in case of large data or file responses."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);