"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3225],{3023(e,n,a){a.d(n,{R:()=>s,x:()=>o});var r=a(3696);const t={},i=r.createContext(t);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:n},e.children)}},9171(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"going-deeper/validation","title":"Validation","description":"Pashmak does not implement its own validation library. Instead, it provides built-in validation support through the @ValidatedRequest decorator, which integrates with popular validation libraries like Yup and Zod.","source":"@site/docs/going-deeper/validation.md","sourceDirName":"going-deeper","slug":"/going-deeper/validation","permalink":"/pashmak/docs/going-deeper/validation","draft":false,"unlisted":false,"editUrl":"https://github.com/devbro1/pashmak/blob/master/docs/docs/going-deeper/validation.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Cache","permalink":"/pashmak/docs/going-deeper/cache"},"next":{"title":"API Documentation Generation","permalink":"/pashmak/docs/going-deeper/api-documentation"}}');var t=a(2540),i=a(3023);const s={sidebar_position:11},o="Validation",d={},l=[{value:"Using Yup Validation",id:"using-yup-validation",level:2},{value:"Basic Example",id:"basic-example",level:3},{value:"Dynamic Schema",id:"dynamic-schema",level:4},{value:"Using Zod Validation",id:"using-zod-validation",level:2},{value:"Dynamic Schema",id:"dynamic-schema-1",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Validation Best Practices",id:"validation-best-practices",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"validation",children:"Validation"})}),"\n",(0,t.jsxs)(n.p,{children:["Pashmak does not implement its own validation library. Instead, it provides built-in validation support through the ",(0,t.jsx)(n.code,{children:"@ValidatedRequest"})," decorator, which integrates with popular validation libraries like Yup and Zod."]}),"\n",(0,t.jsxs)(n.p,{children:["During creating a new pashmak project, you can choose to include validation support with Yup or Zod. If you did not include it during project creation, you can manually add validation support by installing the required packages and adjusting ",(0,t.jsx)(n.code,{children:"src/helpers/validation.ts"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"if you decide to use Both Yup and Zod, you can do that as well:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'export function ValidatedRequest(\n  validationRules:\n    | yup.ObjectSchema<any>\n    | (() => yup.ObjectSchema<any>)\n    | z.ZodType<any>\n    | (() => z.ZodType<any>),\n): ParameterDecorator {\n  return createParamDecorator(async () => {\n    const schema =\n      typeof validationRules === "function"\n        ? validationRules()\n        : validationRules;\n    const requestBody = ctx().get<Request>("request").body;\n\n    // Check if it\'s a Zod schema by checking for parse method\n    if ("parse" in schema && typeof schema.parse === "function") {\n      return await schema.parseAsync(requestBody);\n    }\n\n    // Otherwise, treat it as Yup schema\n    const rc = await (schema as yup.ObjectSchema<any>)\n      .noUnknown()\n      .validate(requestBody, { abortEarly: false });\n\n    return rc;\n  });\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-yup-validation",children:"Using Yup Validation"}),"\n",(0,t.jsx)(n.p,{children:"Yup is a schema validation library that provides an intuitive API for validating objects."}),"\n",(0,t.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import * as yup from "yup";\nimport { BaseController, Controller, Post } from "@devbro/pashmak/router";\nimport { ValidatedRequest } from "@/helpers/validation";\n\n@Controller("/api/v1/users")\nexport class UserController extends BaseController {\n  static createUserSchema = yup.object({\n    name: yup.string().required().min(2).max(100),\n    email: yup.string().email().required(),\n    age: yup.number().positive().integer().min(18),\n  });\n\n  @Post()\n  async create(@ValidatedRequest(UserController.createUserSchema) data: any) {\n    // data is validated and contains: { name, email, age }\n    return await User.create(data);\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"dynamic-schema",children:"Dynamic Schema"}),"\n",(0,t.jsx)(n.p,{children:"You can also use a function to generate schemas dynamically:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"\nconst validationFunc = () => {\n  if (someCondition) {\n    return yup.object({\n      title: yup.string().required().min(10).max(100),\n      content: yup.string().required().min(50),\n      published: yup.boolean().default(true),\n    });\n  }\n\n  return yup.object({\n    title: yup.string().required().min(5).max(200),\n    content: yup.string().required().min(20),\n  });\n};\n\n\n@Post()\nasync update(@ValidatedRequest(validationFunc) data: any) {\n  // Update logic\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"using-zod-validation",children:"Using Zod Validation"}),"\n",(0,t.jsx)(n.p,{children:"Zod is a TypeScript-first schema validation library with static type inference."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { z } from "zod";\nimport { BaseController, Controller, Post } from "@devbro/pashmak/router";\nimport { ValidatedRequest } from "@/helpers/validation";\n\n@Controller("/api/v1/posts")\nexport class PostController extends BaseController {\n  static createPostSchema = z.object({\n    title: z.string().min(1).max(200),\n    content: z.string().min(10),\n    published: z.boolean().default(false),\n    tags: z.array(z.string()).optional(),\n  });\n\n  @Post()\n  async create(@ValidatedRequest(PostController.createPostSchema) data: any) {\n    // data is validated and type-safe\n    return await Post.create(data);\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-schema-1",children:"Dynamic Schema"}),"\n",(0,t.jsx)(n.p,{children:"Zod validation schemas can also be generated dynamically using functions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const validationFunc = () => {\n  if (someCondition) {\n    return z.object({\n      title: z.string().min(10).max(100),\n      content: z.string().min(50),\n      published: z.boolean().default(true),\n    });\n  }\n\n  return z.object({\n    title: z.string().min(5).max(200),\n    content: z.string().min(20),\n  });\n};\n\n@Post()\nasync update(@ValidatedRequest(validationFunc) data: any) {\n  // Update logic\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"When validation fails, it is expected that an error is thrown. You can catch these errors in your httpServer error handler:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// src/initialize.ts\n\nhttpServer().setErrorHandler(async (err: Error, req: any, res: any) => {\n  if (err instanceof HttpError) {\n    res.writeHead(err.statusCode, { "Content-Type": "application/json" });\n    res.write(JSON.stringify({ message: err.message, error: err.code }));\n    logger().warn({ msg: "HttpError: " + err.message, err });\n    return;\n  } else if (err instanceof ZodError) {\n    res.writeHead(422, { "Content-Type": "application/json" });\n    const { errors } = z.treeifyError(err);\n\n    res.write(JSON.stringify({ message: "validation error", errors: errors }));\n    logger().warn({ msg: "ZodError: " + err.message, err });\n    return;\n  } else if (err instanceof yup.ValidationError) {\n    res.writeHead(422, { "Content-Type": "application/json" });\n    const errs: any = {};\n    err.inner.forEach((e: yup.ValidationError) => {\n      // Sanitize sensitive fields\n      const sanitizedParams = { ...e.params };\n      if (/passw/i.test(e.path!)) {\n        sanitizedParams.value = "******";\n        sanitizedParams.originalValue = "******";\n      }\n\n      errs[e.path!] = {\n        type: e.type,\n        message: e.message,\n        params: sanitizedParams,\n      };\n    });\n\n    res.write(JSON.stringify({ message: "validation error", errors: errs }));\n    logger().warn({ msg: "ValidationError: " + err.message, err });\n    return;\n  } else {\n    logger().error({ msg: "Error: " + err.message, err });\n  }\n  res.writeHead(500, { "Content-Type": "" });\n  res.write(JSON.stringify({ error: "Internal Server Error" }));\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"validation-best-practices",children:"Validation Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reuse schemas"}),": Create common validation schemas in a shared location"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Provide clear error messages"}),": Use clear and specific error messages for better user experience"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate early"}),": Use validation to catch errors before they reach your controllers or services"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type safety"}),": Leverage TypeScript types whenever possible for end-to-end type safety"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);