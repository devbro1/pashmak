"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1786],{1928:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"going-deeper/cache","title":"Cache","description":"Caching is a mechanism for storing data in a temporary storage area to reduce the time it takes to access that data in the future.","source":"@site/docs/going-deeper/cache.md","sourceDirName":"going-deeper","slug":"/going-deeper/cache","permalink":"/pashmak/docs/going-deeper/cache","draft":false,"unlisted":false,"editUrl":"https://github.com/devbro1/pashmak/blob/master/docs/docs/going-deeper/cache.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Scheduler and Cron Jobs","permalink":"/pashmak/docs/going-deeper/scheduler"},"next":{"title":"Database/ORM","permalink":"/pashmak/docs/category/databaseorm"}}');var c=a(2540),i=a(3023);const s={sidebar_position:8},t="Cache",o={},d=[{value:"Basic usage",id:"basic-usage",level:2},{value:"put",id:"put",level:3},{value:"has",id:"has",level:3},{value:"get",id:"get",level:3},{value:"delete",id:"delete",level:3},{value:"remember",id:"remember",level:3},{value:"Available cache providers",id:"available-cache-providers",level:2},{value:"memory",id:"memory",level:3},{value:"file",id:"file",level:3},{value:"redis",id:"redis",level:4},{value:"memcache",id:"memcache",level:3},{value:"Disabled Provider",id:"disabled-provider",level:3},{value:"Your own Provider",id:"your-own-provider",level:3},{value:"Advanced usage",id:"advanced-usage",level:2},{value:"cacheQuery",id:"cachequery",level:3},{value:"Registering your own Provider",id:"registering-your-own-provider",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"cache",children:"Cache"})}),"\n",(0,c.jsx)(n.p,{children:"Caching is a mechanism for storing data in a temporary storage area to reduce the time it takes to access that data in the future."}),"\n",(0,c.jsx)(n.p,{children:"ttl: Time To Live, how long a cache value will be kept for."}),"\n",(0,c.jsx)(n.h2,{id:"basic-usage",children:"Basic usage"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'import { cache } from "@devbro/pashmak/facades";\n\nawait cache().put("my_key", value);\nawait cache().put("my_key2", value2, 3600 * 24); // 1 full day\n\nconst user = await cache.get("my_key");\n'})}),"\n",(0,c.jsx)(n.h3,{id:"put",children:"put"}),"\n",(0,c.jsx)(n.p,{children:"to store a value in cache. value must be a primitive type or a simple JSON type.\nA simple JSON type is a type where all keys are string, and all values are either primitive values or simple Json. make sure your json does not have recurive or resource/buffer/stream types."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'import { JSONObject, JSONValue } from "@devbro/pashmak/helpers";\n\nlet value: JSONObject | JSONValue;\nawait cache().put("my_key", value, ttl);\n'})}),"\n",(0,c.jsx)(n.h3,{id:"has",children:"has"}),"\n",(0,c.jsx)(n.p,{children:"If you want to test if a given key exists in cache"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'await cache().put("my_key");\n'})}),"\n",(0,c.jsx)(n.h3,{id:"get",children:"get"}),"\n",(0,c.jsxs)(n.p,{children:["to get a value from inside cache. If key exists, value will be returned.\nif cache does not exists or expired, you will get ",(0,c.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'await cache().get("my_key");\n'})}),"\n",(0,c.jsx)(n.h3,{id:"delete",children:"delete"}),"\n",(0,c.jsx)(n.p,{children:"to remove a cache that is not expired yet."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'await cache().delete("my_key");\n'})}),"\n",(0,c.jsx)(n.h3,{id:"remember",children:"remember"}),"\n",(0,c.jsxs)(n.p,{children:["there may be situations that you want to recalculate your cache using a function and get the value at the same time. This is where you can use ",(0,c.jsx)(n.code,{children:"remember"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'let val = await cache().remember(\n  "my_key",\n  async () => {\n    return expensiveFunction();\n  },\n  { ttl: 600 },\n);\n'})}),"\n",(0,c.jsx)(n.h2,{id:"available-cache-providers",children:"Available cache providers"}),"\n",(0,c.jsx)(n.p,{children:"Different providers are available off the shelf that you can use. depending on which provider you use different configs/options can be passed to it."}),"\n",(0,c.jsx)(n.h3,{id:"memory",children:"memory"}),"\n",(0,c.jsx)(n.p,{children:"The memory cache provider stores data in the application's memory. This is the fastest cache provider but data is lost when the application restarts."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'// app/config/cache.ts\n\nexport default {\n  cache: {\n    default: {\n      type: "memory",\n      config: {\n        maxSize: 1000, // Maximum number of items to store (default: 1000)\n        defaultTTL: 3600, // Default TTL in seconds (default: 1 hour)\n        cleanupInterval: 600, //how often garbage collect expired cache\n      },\n    },\n  },\n};\n'})}),"\n",(0,c.jsx)(n.h3,{id:"file",children:"file"}),"\n",(0,c.jsx)(n.p,{children:"The file cache provider stores data in the filesystem as JSON files. This provides persistence across application restarts but is slower than memory cache."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'// app/config/cache.ts\n\nexport default {\n  cache: {\n    default: {\n      type: "file",\n      config: {\n        cacheDirectory: "./cache", // Cache directory (default: \'./cache\')\n        defaultTTL: 3600, // Default TTL in seconds (default: 1 hour)\n        cleanupInterval: 600, //how often garbage collect expired cache\n      },\n    },\n  },\n};\n'})}),"\n",(0,c.jsx)(n.h4,{id:"redis",children:"redis"}),"\n",(0,c.jsx)(n.p,{children:"The Redis cache provider uses Redis as the caching backend. This provides high-performance caching with persistence and can be shared across multiple application instances."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'// app/config/cache.ts\n\nexport default {\n  cache: {\n    default: {\n      type: "redis",\n      config: {\n        // type: RedisClientOptions\n        url: "redis://redis:6379",\n      },\n    },\n  },\n};\n'})}),"\n",(0,c.jsx)(n.p,{children:"for more advance options please check RedisClientOptions"}),"\n",(0,c.jsx)(n.h3,{id:"memcache",children:"memcache"}),"\n",(0,c.jsx)(n.p,{children:"The Memcache cache provider uses Memcached as the caching backend. Memcached is a high-performance, distributed memory caching system ideal for speeding up systems with distributed memory caching(cache is done in RAM not harddrive)."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'// app/config/cache.ts\n\nexport default {\n  cache: {\n    default: {\n      type: "memcache",\n      config: {\n        location: ["memcache:11211"], // type Memcached.Location\n        options: {}, // type Memcached.options\n      },\n    },\n  },\n};\n'})}),"\n",(0,c.jsx)(n.h3,{id:"disabled-provider",children:"Disabled Provider"}),"\n",(0,c.jsx)(n.p,{children:"If you want to disable caching entirely, you can use the disabled cache provider. This provider does not store any data and all cache operations are no-ops."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'// app/config/cache.ts\nexport default {\n  cache: {\n    default: {\n      type: "disabled",\n    },\n  },\n};\n'})}),"\n",(0,c.jsx)(n.h3,{id:"your-own-provider",children:"Your own Provider"}),"\n",(0,c.jsx)(n.p,{children:"To create your own Cache driver, you can implement CacheProviderInterface and then register with CacheProviderFactory."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"import { CacheProviderInterface } from '../CacheProviderInterface.mjs';\nimport { JSONValue, JSONObject } from '@devbro/neko-helper';\n\nexport class MyCacheProvider implements CacheProviderInterface {\n  constructor(private config: MyConfig) {\n  }\n\n  async get(key: string): Promise<JSONValue | JSONObject | undefined> {\n    ???\n  }\n\n  async put(key: string, value: JSONValue | JSONObject, ttl?: number): Promise<void> {\n    ???\n  }\n\n  async delete(key: string): Promise<void> {\n    ???\n  }\n\n  async has(key: string): Promise<boolean> {\n    ???\n  }\n\n  async incr(key: string, value: number): Promise<number> {\n    ???\n  }\n}\n\n\nCacheProviderFactory.register(\"my_cache\", (opt) => {\n  return new FileCacheProvider(opt);\n});\n"})}),"\n",(0,c.jsx)(n.h2,{id:"advanced-usage",children:"Advanced usage"}),"\n",(0,c.jsx)(n.h3,{id:"cachequery",children:"cacheQuery"}),"\n",(0,c.jsxs)(n.p,{children:["If you want to cache your queries to save time, use the ",(0,c.jsx)(n.code,{children:"cacheQuery"})," function."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'import { cacheQuery } from "@devbro/pashmak/cache";\n\nlet q: Query = User.getQuery().where("age", ">", 18);\n\nconst users = await cacheQuery(q);\nconst users2 = await cacheQuery(q, { ttl: 600 }); // uses cache(\'default\')\nconst users3 = await cacheQuery(q, { ttl: 600, cache_label: "my_redis_cache" }); // uses cache(\'my_redis_cache\')\n'})}),"\n",(0,c.jsx)(n.h2,{id:"registering-your-own-provider",children:"Registering your own Provider"}),"\n",(0,c.jsx)(n.p,{children:"TODO: add how to do it"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},3023:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>t});var r=a(3696);const c={},i=r.createContext(c);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);