"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5987],{2685:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"database/orm-relationships","title":"ORM Relationships","description":"neko-orm can handle relationship among models using RelationshipFactory.","source":"@site/docs/database/orm-relationships.md","sourceDirName":"database","slug":"/database/orm-relationships","permalink":"/pashmak/docs/database/orm-relationships","draft":false,"unlisted":false,"editUrl":"https://github.com/devbro1/pashmak/blob/master/docs/docs/database/orm-relationships.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ORM and Models","permalink":"/pashmak/docs/database/orm-and-model"}}');var o=s(2540),t=s(3023);const i={sidebar_position:4},r="ORM Relationships",l={},c=[{value:"General vocabulary for relation ship",id:"general-vocabulary-for-relation-ship",level:3},{value:"Sample data structure",id:"sample-data-structure",level:3},{value:"1-to-1 aka hasOne",id:"1-to-1-aka-hasone",level:2},{value:"1-to-Many aka hasMany",id:"1-to-many-aka-hasmany",level:2},{value:"Many-to-1 aka belongsTo",id:"many-to-1-aka-belongsto",level:2},{value:"get relationship",id:"get-relationship",level:2},{value:"manage relationship",id:"manage-relationship",level:2},{value:"Many to Many aka belongsToMany",id:"many-to-many-aka-belongstomany",level:2},{value:"queryModifier",id:"querymodifier",level:2},{value:"Polymorphism",id:"polymorphism",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"orm-relationships",children:"ORM Relationships"})}),"\n",(0,o.jsxs)(n.p,{children:["neko-orm can handle relationship among models using ",(0,o.jsx)(n.code,{children:"RelationshipFactory"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"general-vocabulary-for-relation-ship",children:"General vocabulary for relation ship"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"source: the local or the model you are starting from"}),"\n",(0,o.jsx)(n.li,{children:"target: the remote or the model(s) you are associating with"}),"\n",(0,o.jsx)(n.li,{children:"pivot: or the junction table is the intermediary table used to manage M-to-M relationships"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"sample-data-structure",children:"Sample data structure"}),"\n",(0,o.jsx)(n.p,{children:"Examples and test code is based on the following database design:"}),"\n",(0,o.jsx)(n.mermaid,{value:'erDiagram\n  users ||--|| profiles : 1to1\n\n  users ||--o{ posts : 1toM\n\n  posts }o..o{ viewers: "MtoM(using post_viewer)"\n  viewers |o--o{ post_viewer : 1toM\n  posts |o--o{ post_viewer : 1toM\n\n\n  posts |o--o{ taggables : belongsToMany-PolyMorphic\n  images |o--o{ taggables : belongsToMany-PolyMorphic\n  posts }o..o{ tags : "polymorphic MtoM(through taggables)"\n  images }o..o{ tags : "polymorphic MtoM(through taggables)"\n  taggables }|--|| tags: 1toM\n\n\n  comments }o--o| posts : 1toM-PolyMorphic\n  comments }o--o| images : 1toM-PolyMorphic\n\nusers {\n    number id PK\n}\n\nprofiles {\n    number id PK\n    number user_id "references user.id"\n}\n\nposts {\n    number id PK\n    number author_id "references user.id"\n}\n\nviewers {\n  number id PK\n}\n\npost_viewer:::JunctionTableClass {\n  number id PK\n  number post_id "ref post.id"\n  number viewer_id "ref viewer.id"\n}\n\nimages {\n  number id PK\n}\n\ncomments {\n  number id PK\n  string commentable_id "ref image.id or post.id"\n  string commentable_type "image or post"\n}\n\ntags {\n  number id PK\n}\n\ntaggables:::JunctionTableClass {\n  number id PK\n  number tag_id "ref tag.id"\n  string taggable_type "image or post"\n  number taggable_id "ref image.id or post.id"\n}\n\nclassDef JunctionTableClass fill:#f96'}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"post_viewer"})," and ",(0,o.jsx)(n.code,{children:"taggables"})," are junction(aka intermediary, pivot) tables to help with MtoM relationships, there is no model for them."]}),"\n",(0,o.jsx)(n.h2,{id:"1-to-1-aka-hasone",children:"1-to-1 aka hasOne"}),"\n",(0,o.jsx)(n.p,{children:"first step is to define relation among models"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class User extends BaseModel {\n  profile() {\n    return RelationshipFactory.createHasOne<User, Profile>({\n      source: this,\n      targetModel: Profile,\n    });\n  }\n}\n\nclass Profile extends BaseModel {\n  session() {\n    return RelationshipFactory.createBelongsTo<Profile, User>({\n      source: this,\n      targetModel: User,\n    });\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["to make the association, RelationshipFactory predicts possible name of forgein key. if you want to define your own or have multiple primary keys, then define ",(0,o.jsx)(n.code,{children:"sourceToTargetKeyAssociation"})," in the options."]}),"\n",(0,o.jsx)(n.p,{children:"once the relationship is established you can get the child relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.profile().get();\n"})}),"\n",(0,o.jsx)(n.p,{children:"adding to a relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.profile().associate(profile);\n"})}),"\n",(0,o.jsx)(n.p,{children:"removing from a relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.profile().dessociate(profile);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you need to do the save step yourself just pass ",(0,o.jsx)(n.code,{children:"sync:false"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.profile().associate(profile, { sync: false });\nawait profile.save();\n\nawait user.session().associate(profile, { sync: false });\nawait profile.save();\n"})}),"\n",(0,o.jsx)(n.h2,{id:"1-to-many-aka-hasmany",children:"1-to-Many aka hasMany"}),"\n",(0,o.jsx)(n.p,{children:"first step is to define relation among models"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class User extends BaseModel {\n  comments() {\n    return RelationshipFactory.createHasMany<User, Post>({\n      source: this,\n      targetModel: Post,\n    });\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["to make the association, RelationshipFactory predicts possible name of forgein key. if you want to define your own or have multiple primary keys, then define ",(0,o.jsx)(n.code,{children:"sourceToTargetKeyAssociation"})," in the options."]}),"\n",(0,o.jsx)(n.p,{children:"once the relationship is established you can iterate among children"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"for (const post of await user.posts().toArray()) {\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"if you run into a situation where you have too many children then you can easily async iterate"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"for await (const post of user.posts()) {\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"this approaches loads one model at a time from database."}),"\n",(0,o.jsx)(n.p,{children:"adding to a relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.posts().associate(post1);\nawait user.posts().associate([post2, post3]);\n"})}),"\n",(0,o.jsx)(n.p,{children:"removing from a relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.posts().dessociate(post1);\nawait user.posts().dessociate([post2, post3]);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you need to do the save step yourself just pass ",(0,o.jsx)(n.code,{children:"sync:false"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await user.posts().associate(post1, { sync: false });\nawait post1.save();\n\nawait user.posts().dessociate(post1, { sync: false });\nawait post1.save();\n"})}),"\n",(0,o.jsx)(n.h2,{id:"many-to-1-aka-belongsto",children:"Many-to-1 aka belongsTo"}),"\n",(0,o.jsx)(n.p,{children:"As a reverse relationship of hasMany you can define it as such"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'class Post extends BaseModel {\n  @Attribute()\n  declare author_id: number;\n\n  author() {\n    return RelationshipFactory.createBelongsTo<Post, User>({\n      source: this,\n      targetModel: User,\n      sourceToTargetKeyAssociation: {\n        author_id: "id",\n      },\n    });\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"get-relationship",children:"get relationship"}),"\n",(0,o.jsx)(n.p,{children:"since there is only 1 object that can be returned, use get() instead"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"let author = await post.author().get();\n"})}),"\n",(0,o.jsx)(n.h2,{id:"manage-relationship",children:"manage relationship"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await post.author().associate(author);\nawait post.author().dessociate(author);\n\n//faster way of dessociate\nawait post.author().unlink();\n"})}),"\n",(0,o.jsx)(n.p,{children:"keep in mind that these methods are modifying source(post model) and leaving target model alone(user)"}),"\n",(0,o.jsx)(n.h2,{id:"many-to-many-aka-belongstomany",children:"Many to Many aka belongsToMany"}),"\n",(0,o.jsx)(n.p,{children:"To establish the relationship between two models:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export class Viewer extends BaseModel {\n  posts() {\n    return RelationshipFactory.createBelongsToMany<Viewer, Post>({\n      source: this,\n      targetModel: Post,\n    });\n  }\n}\n\nexport class Tag extends BaseModel {\n  viewer() {\n    return RelationshipFactory.createBelongsToMany<Post, Viewer>({\n      source: this,\n      targetModel: Viewer,\n    });\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"if you want to make further configurations you can:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"posts() {\n  return RelationshipFactory.createBelongsToMany<Viewer, Post>({\n    source: this,\n    targetModel: Post,\n    junctionTable: 'post_viewer',\n    sourceToJunctionKeyAssociation: {id: viewer_id}, //id is viewer.id\n    junctionToTargetAssociation: { post_id: id} //id is post.id\n  });\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"to make association between new model objects:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await post.viewers().associate([viewer1, viewer2, viewer3]);\n"})}),"\n",(0,o.jsx)(n.p,{children:"and to remove:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await post.viewers().dessociate([viewer1, viewer2, viewer3]);\n"})}),"\n",(0,o.jsx)(n.p,{children:"NOTE: there is currently no sync=false for MtoM relationships"}),"\n",(0,o.jsx)(n.p,{children:"to get all associated models you can use toArray() or iteration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await post.viewers().toArray();\nfor await (const viewer of post.viewers()) {\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"querymodifier",children:"queryModifier"}),"\n",(0,o.jsxs)(n.p,{children:["In order to pull data from database, ",(0,o.jsx)(n.code,{children:"RelationshipManager"})," will generate a query object. you will have an opportunity to modify this query object to further change which records are pulled. ",(0,o.jsx)(n.code,{children:"queryModifier"})," can be an async method in case you need to ",(0,o.jsx)(n.code,{children:"await"})," in your function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export class User extends BaseModel {\n  // ...\n\n  posts() {\n    return RelationshipFactory.createHasMany<User, Post>({\n      source: this,\n      targetModel: Post,\n      sourceToTargetKeyAssociation: {\n        id: "author_id",\n      },\n    });\n  }\n\n  topPosts() {\n    return RelationshipFactory.createHasMany<User, Post>({\n      source: this,\n      targetModel: Post,\n      sourceToTargetKeyAssociation: {\n        id: "author_id",\n      },\n      queryModifier: async (query: Query) => {\n        return query.whereOp("rating", ">", 8); //where posts.rating > 0\n      },\n    });\n  }\n\n  // ...\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,o.jsx)(n.p,{children:"Polymorphism referes to the concept where two different type of models can relate to same object. for example, image and posts can have comments."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},3023:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>r});var a=s(3696);const o={},t=a.createContext(o);function i(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);